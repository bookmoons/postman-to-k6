const aid = require('./aid')
const filenamify = require('filenamify')
const prettier = require('prettier')
const { VariableType } = require('./enum')

const empty = `// No HTTP/HTTPS transactions have been recorded`
const staticImports = [ './libs/shim/core.js' ]

function render (result) {
  if (!result.main.length) {
    return [ empty, {} ]
  }
  const requests = renderRequests(result)
  const raw = [
    header(),
    imports(result, requests),
    options(result),
    data(result),
    initial(result),
    logic(result)
  ].filter(section => section).join(`\n\n`)
  const main = prettier.format(raw, { semi: true, parser: 'babel' })
  return [ main, requests ]
}

function header () {
  return `// Auto-generated by the Load Impact converter`
}

function imports (result, requests) {
  const direct = []
  const indirect = {}
  for (const [ name, spec ] of result.imports) {
    if (typeof spec === 'object') {
      const { base } = spec
      if (!(base in indirect)) {
        indirect[base] = []
      }
      indirect[base].push(name)
    } else {
      direct.push([ name, spec ])
    }
  }
  const lines = []
  for (const path of staticImports) {
    lines.push(staticImport(path))
  }
  for (const item of result.effectImports) {
    lines.push(`import ${JSON.stringify(item)};`)
  }
  if (requests) {
    for (const file of Object.keys(requests)) {
      const path = `./requests/${file}`
      lines.push(`import ${JSON.stringify(path)};`)
    }
  }
  for (const [ name, path ] of direct) {
    lines.push(imp(name, path))
  }
  for (const key of Object.keys(indirect)) {
    const name = `{ ${indirect[key].join(`, `)} }`
    lines.push(imp(name, key))
  }
  return lines.join(`\n`)
}

function staticImport (path) {
  return `import ${JSON.stringify(path)};`
}

function imp (name, path) {
  return `import ${name} from ${JSON.stringify(path)};`
}

function options (result) {
  if (result.iterations > 1) {
    result.options.iterations = result.iterations
  }
  if (!Object.keys(result.options).length) {
    return null
  }
  return `export let options = ${JSON.stringify(result.options)};`
}

function data (result) {
  if (!result.data.path) {
    return null
  }
  const parse = dataParse(result)
  const sections = []
  sections.push(`const file = (() => {
  // Load data file
  const text = open(${JSON.stringify(result.data.path)});
  const rows = ${parse};
  return rows;
})();`)
  if (result.iterations === null) {
    sections.push(`options.iterations = file.length;`)
  }
  return sections.join(`\n`)
}

function dataParse (result) {
  switch (result.data.type) {
    case 'csv':
      return `papaparse.parse(text, { header: true }).data`
    case 'json':
      return `JSON.parse(text)`
    default:
      throw new Error(`Unrecognized data file type: ${result.data.type}`)
  }
}

function initial (result) {
  const lines = []
  if (iterationMessage(result)) {
    lines.push(`const Iteration = Symbol.for("iteration");`)
  }
  for (const [ name, label ] of result.symbols) {
    lines.push(`const ${name} = Symbol.for(${JSON.stringify(label)});`)
  }
  if (result.setting.separate) {
    lines.push(`const NamedRequest = Symbol.for("named");`)
  } else {
    lines.push(`const Request = Symbol.for("request");`)
  }
  const initial = [
    `options`,
    globalScope(result),
    collectionScope(result),
    environmentScope(result),
    dataScope(result)
  ].filter(item => item)
  const args = initialArgs(initial)
  lines.push(`postman[Symbol.for("initial")](${args});`)
  return lines.join(`\n`)
}

function globalScope (result) {
  if (result.scope.global.size) {
    return `global: ${vars(result.scope.global)}`
  } else {
    return null
  }
}

function collectionScope (result) {
  if (result.scope.collection.size) {
    return `collection: ${vars(result.scope.collection)}`
  } else {
    return null
  }
}

function environmentScope (result) {
  if (result.scope.environment.size) {
    return `environment: ${vars(result.scope.environment)}`
  } else {
    return null
  }
}

function dataScope (result) {
  if (result.data.path) {
    return `data: file`
  } else {
    return null
  }
}

function initialArgs (initial) {
  if (initial.length) {
    return `{
${aid.indent(initial.join(`,\n`))}
}`
  } else {
    return ``
  }
}

function vars (spec) {
  const items = []
  for (const item of spec) {
    if (item[1] === undefined) {
      continue
    }
    const name = JSON.stringify(item[0])
    const value = varValue(item[1])
    items.push(`${name}: ${value}`)
  }
  return `{
${aid.indent(items.join(`,\n`))}
}`
}

function varValue (spec) {
  switch (spec.type) {
    case VariableType.Boolean:
    case VariableType.Number:
    case VariableType.Literal:
      return spec.value
    case VariableType.Json:
    case VariableType.String:
      return JSON.stringify(spec.value)
    default:
      throw new Error(`Unrecognized variable type: ${spec.type}`)
  }
}

function logic (result) {
  return `export default function() {
${aid.indent(outer(result))}
}
`
}

function outer (result) {
  return [
    declares(result),
    iteration(result),
    enter(result),
    main(result),
    exit(result)
  ].filter(section => section).join(`\n\n`)
}

function body (spec, result) {
  return [
    declares(spec),
    enter(spec),
    main(spec, result),
    exit(spec)
  ].filter(section => section).join(`\n\n`)
}

function declares (spec) {
  if (!spec.declares.size) {
    return null
  }
  return `let ${[ ...spec.declares ].join(`, `)};`
}

function enter (spec) {
  const sections = []
  if (spec.pre) {
    sections.push(`postman[Pre].push(() => {
${aid.indent(spec.pre)}
});`)
  }
  if (spec.post) {
    sections.push(`postman[Post].push(() => {
${aid.indent(spec.post)}
});`)
  }
  if (sections.length) {
    return sections.join(`\n`)
  } else {
    return null
  }
}

function exit (spec) {
  const sections = []
  if (spec.pre) {
    sections.push(`postman[Pre].pop();`)
  }
  if (spec.post) {
    sections.push(`postman[Post].pop();`)
  }
  if (sections.length) {
    return sections.join(`\n`)
  } else {
    return null
  }
}

function iteration (result) {
  if (iterationMessage(result)) {
    return `postman[Iteration]();`
  } else {
    return null
  }
}

function iterationMessage (result) {
  return !!result.data.path
}

function main (spec, result = spec) {
  const separator = `\n`.repeat(result.setting.separate ? 1 : 2)
  return spec.main.map(item => chunk(item, result)).join(separator)
}

function chunk (item, result) {
  if (!item) {
    return ``
  }
  const type = typeof item
  switch (type) {
    case 'string':
      return item
    case 'object':
      if (Array.isArray(item)) {
        return item.join(`\n`)
      } else {
        return group(item, result)
      }
    default:
      throw new Error('Invalid chunk type: ' + type)
  }
}

function group (spec, result) {
  return `group(${JSON.stringify(spec.name)}, function () {
${aid.indent(body(spec, result))}
});`
}

function renderRequests (result) {
  if (!result.setting.separate) {
    return null
  }
  const bases = new Set()
  const files = new Map()
  const requests = {}
  for (const name of Object.keys(result.request)) {
    for (const spec of result.request[name]) {
      const base = encodeFilename(name)
      const file = nextFilename(base, bases, files)
      requests[file] = renderRequest(spec)
    }
  }
  return requests
}

function renderRequest (spec) {
  return `postman[Symbol.for("define")](${spec});
`
}

function encodeFilename (name) {
  return filenamify(shrink(name))
}

function shrink (string) {
  let result = ''
  let raise = false
  for (const character of string) {
    if (character === ' ') {
      raise = true
      continue
    } else if (raise) {
      raise = false
      result += character.toUpperCase()
    } else {
      result += character
    }
  }
  return result
}

function nextFilename (base, bases, files) {
  if (!bases.has(base)) {
    bases.add(base)
    files[base] = aid.SuffixGenerator()
  }
  const suffix = files[base].next().value
  if (suffix) {
    return `${base}.${suffix}.js`
  } else {
    return `${base}.js`
  }
}

module.exports = render
